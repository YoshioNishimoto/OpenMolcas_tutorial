# 一点計算（入力ファイル）

エネルギーの計算（プロパティの計算含む）を一点計算（single-point calculation）と呼びます。
「一点の構造での計算」という意味です。
そうでない計算は、例えば構造最適化計算や分子動力学シミュレーションのように、分子構造を変化させていく計算です。

量子化学計算を（まじめに）行うには、もちろん量子化学の理論を勉強しておく必要があります。
ここでの量子化学は学部で勉強する量子化学とはやや異なるかもしれません。
量子化学計算に直接関連する理論については、例年Szabo & Ostlundの教科書で勉強することとなっています。
もう一つ、量子化学の理論だけでなく、計算を行うにはプログラムの使い方を把握しておく必要があります。
量子化学計算プログラムはたくさん存在するので、使用するプログラムに応じて使い方を勉強しなければいけません。
ここではOpenMolcasの使い方ということになりますが、他のプログラムを使うときはまた異なる使い方となります。
その場合はマニュアルを参考に勉強します。
ちなみに、OpenMolcasのマニュアルは[HTML](https://molcas.gitlab.io/OpenMolcas/sphinx/)と[PDF](https://molcas.gitlab.io/OpenMolcas/Manual.pdf)が用意されています。
英語ですが。

## OpenMolcasの計算方法

[前回](00_introduction.md)で行ったとおり、OpenMolcasをインストールできて、入力ファイル（インプットファイル; 以下の例では`test.input`）を用意できたことにしておきます。
前回は`molcas-gnu_dev_omp`または`molcas-gnu_dev_ga`という実行ファイルを使って
```
$ ~/OpenMolcas/molcas-gnu_dev_omp test.input
```
によりOpenMolcasを使った計算をしました。
ちなみに、入力ファイルの拡張子はどんなものでもOKですし、なくてもOKです。
`molcas-gnu_dev_omp`の中身は
```
#!/bin/sh
export MOLCAS=/home/nisimoto/OpenMolcas/builds/gnu_dev_omp
${MOLCAS}/pymolcas $*
```
というようなものでした。
1行目はおまじない（ではありませんが、OpenMolcasとは関係ないです）。
2行目は`MOLCAS`という環境変数を設定し、OpenMolcasをビルドしたディレクトリを指定します。
複数のビルドを置いてある環境でも、この環境変数を設定することで簡単に使い分ける[^1]ことができます（例えばGA並列のあり・なし）。
3行目が実際に計算するところです。
`pymolcas`というPythonスクリプトを用いて計算を始めるというところです。
この実行ファイルは簡単な名前をつけてパスを通しておくと良いでしょう。

他にも設定すると便利かもしれない環境変数としては
- `MOLCAS_MAXMEM`: 計算で使う最大メモリ（MB単位）（例: `export MOLCAS_MAXMEM=2000`）
- `MOLCAS_WORKDIR`: 計算の作業用ディレクトリ（例: `export MOLCAS_WORKDIR=/dev/shm`）
- `MOLCAS_KEEP_WORKDIR`: 作業用ディレクトリを削除するかどうか（例: `export MOLCAS_KEEP_WORKDIR=NO`）

あたりでしょうか。
詳細はマニュアルのセクション4.1.2.5 System variables参照。
これらの環境変数はインプットファイルでも設定できたと思います。

## インプットファイルの一般的な構造

インプットファイルには計算で使うモジュール名（例えば`&GATEWAY`や`&SEWARD`）とオプション（例えば`coord=2`や`NoCD`など）を書いていきます。
一般的には大文字と小文字は区別されません。
書きやすさや読みやすさで決めましょう。
セミコロン（`;`）を使うと改行の代わりになります。
行の初めに`*`を置くと、コメント行になります。
`OpenMolcas`ディレクトリ中にある`test`というディレクトリにインプットファイルの例がたくさんありますので、必要に応じて参照してみましょう。

モジュール名の場合は`&`から始めて計算で使うモジュール名を指定します。
このモジュール名は省略できませんので、よく使うものはマニュアルを読んで覚えましょう。
例えば`&GATEWAY`は、計算で使う分子や計算の詳細（基底関数など）を指定するモジュールです。
`&SEWARD`[^2]は一電子積分（特に一電子ハミルトニアン。電子の運動エネルギーや核–電子間相互作用）および二電子積分（電子反発積分）[^3]を計算するモジュールです。
この二つは、基本的にどの計算をするときでも必要になると思われます。
そして`&SCF` (self-consistent field)はHartree–Fockの計算を行うモジュールです。
他にもこのチュートリアルで少なくとも`&RASSCF`、`&CASPT2`、`&MCLR`、`&ALASKA`、`&SLAPAF`あたりは使う予定です。
なお、場合によってはモジュールが他のモジュールを自動で呼ぶ設定になっているので、省略できるモジュールもあります（`&MCLR`は省略されることが多い）。
それぞれのモジュールは`&GATEWAY &END`のように書いても構いません（別の行にはできないはず）。
また、それぞれのモジュールが終わるところで`end of input`などと書くこともできます（自分は書かない）。

それぞれのモジュールで書くことができるオプションが決まっています。
例えば`coord=2`は`&GATEWAY`用のオプションなので、`&SCF`のところに書いても意味がありません。
オプションによってはオプションを書くだけというものがあります（例えば`NoCD`）。
一方、イコールをつけて、あるいはつけずに値を書かないといけない場合もあります。
例えば`Basis = 6-31G*`というのはイコールの右辺が値ということになります。
このときイコールは省略できません[^4]。
ですが、[前回使ったファイル](input_files/00_test.input)の場合、
```
&GATEWAY
  Coord
  2
  Angstrom
  H 0.0 0.0 0.0
  H 1.0 0.0 0.0
  Basis
  6-31G*
  Group
  C1
  NoCD
```
のように、次の行に値を書くようにするとイコールを省略できます。
このあたりは試行錯誤の末に覚えましょう。

モジュール名とはちがい、オプション名は短縮できる場合があります。
ここまでの例ではマニュアルを読んでも短縮できるオプションはなさそうですが、
`&SCF`中の収束しきい値を指定するオプションは`THRESHOLDS`というものです。
マニュアルには**THRE**SHOLDS（"THRE"部分はもう少し大きい）のような書き方をされており、
プログラム内部では「THRE」部分だけでオプションを判定しています。
多くの部分は最大4文字で判定しています（全部なのかは分かりません）。
マニュアルには省略できる書き方がされていなくても、上の例だと`Coor`、`Angs`、`Basi`、`Grou`で十分であったりします。
個人的にはわかりやすい書き方をしておいた方が良いと思いますが。

## EMILコマンド

詳細はマニュアルのセクション4.1.3 (General input structure. EMIL commands)参照。
`>`で始まる行はEMILコマンドとよび、やや特殊な操作をすることができます。
こちらも大文字・小文字の区別はありません。

自分が使うEMILコマンドは固定されておりそれほど詳しくないので、使うときに紹介していきます。
使う予定のコマンドは
- `> DO WHILE`
- `> ENDDO`または`> END DO`
- `> IF (ITER = 1)`
- `> COPY`
あたりかなと思います。

## モジュールとオプションの詳細

[前回使ったファイル](input_files/00_test.input)は
```
&GATEWAY
  Coord = 2
  Angstrom
  H 0.0 0.0 0.0
  H 1.0 0.0 0.0
  Basis = 6-31G*
  Group = C1
  NoCD

&SEWARD

&SCF
```
というようなものでした。

### 原子の指定

このファイルはH<sub>2</sub>分子のエネルギーを計算します。
一般的にはXYZ形式のファイルで書くのが良いでしょう。
XYZ形式のファイルは1行目が原子数、2行目がコメント行、3行目以降は一列目が元素で二列目・三列目・四列目がそれぞれX軸、Y軸、Z軸方向の原子核の座標を表します。
すると、`Coord = 2`は計算する分子の原子数です。
二行目の`Angstrom`はコメント行なので何を書いても構いませんが、空白行はOKでも省略することはできません。
三行目以降は原子の座標をAngstrom単位（コメント行でAngstromと書いていることとは関係ありません）で書くことを宣言し、その次の二行で二つの水素原子をそれぞれ`0.0 0.0 0.0`と`1.0 0.0 0.0`という座標に置くことを意味します。
すなわち、このH<sub>2</sub>分子の原子間距離は1.0 Angstromです。
座標を適当に変更することにより、原子間距離を変更できます。
他の分子を計算したい場合は`Coord`の値と元素・座標を変更しましょう。
計算する分子は直接インプットファイルに書く必要はありません。
例えば`water.xyz`というXYZ形式のファイルを用意し、インプットファイルに`coord = water.xyz`のように書いて指定することもできます。

### 基底関数の指定

`Basis = 6-31G*`は**基底関数**を指定しています。
基底関数が量子化学計算に導入される過程は一応Szabo: Sec.3.4.2に書いてあります。
簡単に言えば、狭義のHartree–Fock方程式（積分微分方程式）を数値的に解くのは難しいため、基底関数を導入してHartree–Fock–Roothaan方程式を解くようにしています。
こうすると、微分方程式から線形代数の問題へ変換でき、ご存じ（？）の通り、繰り返し計算を行うことで割と簡単に方程式を解くことができます。
基底関数は、原子の上に置く関数のことで、分子軌道（$`\psi_i`$）は基底関数（原子軌道）（$`\chi_\mu`$）の線形結合により表されます。
よくLCAO (linear combinations of atomic orbitals)とかいうやつですね。
```math
\displaystyle \psi_i = \sum_\mu \chi_\mu C_{\mu i}
```
(Szabo: 式(3.133))。
$` \displaystyle C_{\mu i}`$は分子軌道係数です。詳しくはSzabo: Sec.3.4.2や3.5.1をご参照ください。
量子化学の授業でも出てきた概念だと思います。
例えばヒュッケル法を用いてベンゼンの永年方程式を解くと、6つのp軌道（これが原子軌道）の組み合わせで6つのπ軌道・π*軌道（これが分子軌道）が出てくることを確認しました。
量子化学計算でも同じようなことをしていますが、p軌道だけではなくs軌道、d軌道、f軌道･･･と高次の角運動量を持つ軌道関数を用いることも少なくありません。
また、主量子数に関しても量子化学で勉強する以上の値を用いることも少なくありません（例えばC原子でも3s, 3p, 3d軌道を用いたり）。

予想されるとおり、基底関数が大きければ大きいほど（与えられた手法の中で）厳密な結果に近づいていきます。
無限に大きな基底関数を用いることができれば良いのですが、無限に計算時間が必要なため、有限の基底関数を用いる必要があります。
現実には、手元の計算リソースで用いることができる最大の基底関数を用いて研究を行っていく必要があります。
と言っても、ある程度妥協は必要ですが。

上記の例では`Basis = 6-31G*`としており、いわゆるPople系の基底関数と呼んだりしています。
水素原子の場合はs軌道を2つ（正確ではないですが1s + 2s）用いるという基底関数です。
炭素原子の場合はs軌道3つ、p軌道2つ、d軌道1つ（1s + 2s + 3s + 2p + 3p + 3d）だったと思います。
他にもcc-pVDZ (correlation consistent polarized valence double zeta)という基底関数を用いたりするかもしれません。
当面はcc-pVDZ（`Basis = cc-pVDZ`）、6-31G(d)/6-31G*、STO-3G（`Basis = STO-3G`）あたりを用いれば良いと思います。
上に挙げた順に、用いる関数の数が減っていきます（STO-3Gが上記の最小）。
指定できる基底関数の数は非常に多く、到底ここでご紹介できるものではありません。
他の選択に興味があれば、[EMSL](https://www.basissetexchange.org/)等をご参照ください。
また、どの角運動量の関数を用いているか等も知っておくと良いでしょう（Frank Jensen: Introduction to Computational Chemistryの5章が分かりやすいのですが･･･）。

時間があれば、`Basis = cc-pVTZ`（cc-pVTZ基底関数）、`Basis = cc-pVQZ`（cc-pVQZ基底関数）を試して（計算時間が増えるので注意）みましょう。
大きな基底関数ほど、高次の角運動量の関数（f関数、g関数、...）を用いる、あるいは同じ角運動量でも多くの関数を用いていく（関数の広がり方が異なる）ようになります。
ここで行うHartree–Fock計算はエネルギー式が占有軌道だけで書くことができ、それほど高い角運動量（および主量子数）を使わなくてもかなり良い感じに記述できる（HF/DFTが基底関数依存性が少ないと言われるゆえん）のですが、
非占有軌道がエネルギーの式に入ってくる計算（電子相関）の場合は非占有軌道の質も重要になってくるため、大きめの基底関数を使うことが望ましいです。

### 対称性の指定

「化学数学」で勉強したとおり、分子によっては対称性があり、対称性を利用することで計算を簡単にしたり、結果を解釈しやすくしたりすることができます。
OpenMolcasの場合はアーベル群（Abelian group）のみ使うことができます。
H<sub>2</sub>は$`D_{\infty \mathrm{h}}`$（Abelian group or not?）ですが、上記の例では$`C_1`$で計算しています。
対称性を使いたい場合は`Group = C1`のところを`Group = Full`にしてみましょう。
基本的には勝手に適切な対称性を認識して、いい具合にやってくれます。
それ以外の指定はマニュアル参照。

### Cholesky decomposition

`NoCD`というのは電子反発積分（二電子積分）の計算にCholesky decompositionを**使わない**というオプションです。
使わない方が、伝統的な量子化学計算です。
ですが、二電子積分は原子軌道の4乗に比例して扱う数が大きくなっていくので、これを避けるために（近似的に）コレスキー分解をしてから保存しておくということをしています。
これにより必要なディスク容量を削減し、計算の高速化をすることができます。
コレスキー分解を使う場合は`NoCD`の代わりに`RICD`としましょう。
なお、コレスキー分解は「RI近似」(resolution-of-the-identity)や「DF近似」（density fitting）と呼ばれるものとほとんど同じです。
RI/DF近似の場合は前もって作成した補助基底関数を与えないといけないのに対して、
コレスキー分解の場合は用いる基底関数から自動的に補助基底関数を作ってくれるため、ユーザーが補助基底関数を指定する必要がなくなります。
ただ、コレスキー分解は補助基底関数の数が多くなりがちです。

### &SEWARD

このチュートリアルの範囲では特に説明することはないでしょう。
SOC (spin–orbit coupling)をやるなら使うかも？

### &SCF

`SCF`は"self-consistent field"の事です。
日本語では「自己無撞着場（じこむどうちゃくば）」とか「自己無矛盾場（じこむむじゅんば）」とか訳されたりしますが、
逆に意味が分からないのでSCFなりself-consistent fieldなり書きましょう。
実際にはHartree–Fockの計算をしている[^5]わけですが、詳細はSzabo & Ostlundの教科書で勉強することになると思います（主にChapter 3）。
Hartree–Fock計算の結果をそのまま論文で使うことはほとんどありませんが、
多配置計算の初期軌道を作るのに使ったり、電子相関計算の初期波動関数としたりするため、使う機会は多いと思います。
`&SCF`の中で電荷やスピン多重度を指定することができます（マニュアル参照）。

上向きスピンと下向きスピンの電子をつめる分子軌道を同じとする場合、制限(restricted) Hartree–Fock (RHF)法と呼んだりします。
スピン多重度が1の場合は**基本的に**制限Hartree–Fock法の計算を行います。
スピン多重度が1でない場合は、別々の分子軌道を用いる場合は非制限(unrestricted) Hartree–Fock (UHF)法、
同じ分子軌道を用いる場合は制限開殻(restricted open-shell) Hartree–Fock (ROHF)法と呼んだりします。
ROHFはCASSCFを使って表現できるので、OpenMolcasはROHFが扱えない？

## 演習問題

- アーベル群で最も対称性が高い点群は？
- H<sub>2</sub>O（H-O距離が1.0 Angstrom、H-O-Hが120度）のHF/cc-pVDZ、HF/cc-pVTZ、HF/cc-pVQZのエネルギーを計算してみましょう。
また、それぞれの「相対エネルギー」をkcal/mol単位（小数点二桁までで良い）で計算してみましょう。
計算時間を比較してみると良いかもしれません。
今回は初めての計算ということで、私が計算した結果でも（PySCFの計算結果をコピーしたものですが、HFならたぶん同じでしょう･･･）。
基底関数の大きさとしては、cc-pVDZ < cc-pVTZ < cc-pVQZです。

| 基底関数 | エネルギー（hartree)| 計算時間（秒）|
| ------- | ----------------- | ------------ |
| cc-pVDZ | -76.0142704701529 | 0.046        |
| cc-pVTZ | -76.0448154851462 | 0.085        |
| cc-pVQZ | -76.0525392908608 | 0.879        |

- 基底関数が大きくなると、基本的にはエネルギーが減少していきます。なぜでしょうか。
- `&SCF`の中で電荷を指定するオプションを探してhydroxy anionの計算をしてみましょう。
- 同様にスピン多重度を指定するオプションを探してhydroxy radicalの計算をしてみましょう。OpenMolcasでは同じインプットファイルに同じモジュールを複数回書くことができます。hydroxy anionとhydroxy radicalを一つのインプットファイルで計算してみましょう。
- 次の構造を用いて$`D_{2\mathrm{h}}`$対称の計算をしてみましょう。`&SEWARD`の`Group`でどのようなオプションを入れると良いでしょうか（一通りではないです。`Group = Full`以外でやりましょう）。正しい計算ができると、`++    Symmetry information:`のところに$`D_{2\mathrm{h}}`$の指標表が表示されると思います。$`C_1`'の計算とエネルギーが一致するでしょうか。
```
  C       -0.665079000      0.000000000      0.000000000
  C        0.665079000      0.000000000      0.000000000
  H       -1.238029000      0.923341000      0.000000000
  H       -1.238029000     -0.923341000      0.000000000
  H        1.238029000      0.923341000      0.000000000
  H        1.238029000     -0.923341000      0.000000000
```

- 他の任意の分子に関しても、時間があれば同様の計算をしてみましょう。
ただし原子の数が多いと、分子構造の座標を作成するのが面倒（実際には可視化ソフトウェアを用いて分子構造を作成します）だったり、計算時間がとても長くなります。

[^1]: 計算を行うディレクトリがOpenMolcasのインストールディレクトリより下にある場合は、`MOLCAS`の環境変数にかかわらず最後にインストールした（`make install`が必要？）OpenMolcasが使われることがあります。
[^2]: アラスカ州の都市から来ているはず。OpenMolcasには`&ALASKA`というモジュールもあり、エネルギーの微分を計算するときに使います。
[^3]: 相対論では二電子積分と電子反発積分は区別するべきらしい。
[^4]: あまり使われないオプションの中には、省略して値を与えないといけないオプションもあったと思う。
[^5]: 原理主義者からすると、Hartree–Fockは完全基底系での手法であり、ここで行うような部分空間を用いる場合はあくまでSCFレベルなのだとか。
