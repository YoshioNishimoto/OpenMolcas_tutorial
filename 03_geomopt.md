# 構造最適化

構造最適化（geometry optimization）をします。
構造最適化は、ポテンシャルエネルギー面（PES; potential energy surface）の極値を見つけることです。
PESは、教科書とかでは三次元で書かれますが、実際には$`3N_\mathrm{atom}-6`$次元（自由度に一致。直線分子の場合は？）の超曲面になります。
イメージしづらいですが。
「極値」だと、極小値・極大値のどちらを計算しているのか分かりませんが、とりあえずここでは極小値を計算することを考えています。
極大値の計算は、可能であれば別の機会に･･･。
極大値は一般的に鞍点（あんてん; saddle point）と呼ばれており、$`3N_\mathrm{atom}-6`$つの基準振動の中で一つの振動モードのみが上に凸の場合に、
遷移構造・遷移状態（TS; transition structure, transition state）と呼ばれています。

教科書的に、分子のエネルギーの極小値を計算するというのは、例えばH<sub>2</sub>分子のPESの極小値を求めるというのはありうるかと思います。
二原子分子の場合は自由度が1であったため、自由度に対応する原子間距離を変化させながらエネルギーを計算し、横軸に原子間距離と縦軸にエネルギーをプロットすると、極小値を同定することができます。
ですがこれ以上大きな分子、三原子分子であったとしても自由度は3つとなり、例えば自由度の軸に沿ってそれぞれ10個の一点計算をするとしても、三つの軸に沿って原子を動かしていくと、最終的に1000回の一点計算が必要になります。
しかも、この計算を行ったとしても必ず極小値が見つかるわけではないですし、しかもそれぞれの軸に沿って10個の計算を行ったとしてもかなり荒い近似的な極小値（せいぜい精度は0.1 Angstrom程度と考えられる）しか見つかりません。
そこで、構造最適化をして自動かつ正確に極小値を求めます。

構造最適化するためには、勾配（gradient）を計算します。エネルギーを原子の核座標に関して一次微分したものです。
計算した勾配は、構造最適化中に原子を動かす方向を決めるのに必要で、そして収束条件の判定（極値では勾配がゼロになっているはずなので、ある閾値よりも勾配が小さくなっていれば、構造最適化が収束したと判断する）にも用います。
計算の詳細は置いておいて･･･この勾配は多くの場合、解析的（analytic）に計算します。
これは高校で勉強したような、$`f(x) = x^n`$から$`f(x) = nx^{n-1}`$を計算するような方法です。
高校で勉強したと思われる導関数の定義を用いて、数値的（numerical）な計算をしているわけではありません。
つまり、勾配を計算する際に、少し原子を動かしてエネルギーを計算し、そのエネルギーの差分をとる･･･ということは**していません**。
原子は動かしますが、別の理由です。

関数の場合は勾配を計算してやれば、$`f^\prime(x) = 0`$となる$`x`$を計算することで極値も求められますが、
量子化学計算は自由度が大きいためそのようにして極値を求めることができません。
そのため、勾配を計算して、その勾配（や近似的、あるいは解析的二次微分）にしたがって原子を動かし、
新しい構造を用いて勾配を計算して･･･というように繰り返し計算を行います。
このため、エネルギーと勾配の計算を繰り返し行っていく必要が出てきます。

量子化学計算では、多くの場合まず構造最適化計算をして、その構造でのエネルギーやプロパティを用いて議論を行います。
というのも、エネルギーが低い構造ほどその分子構造（配座？）をとる確率が高くなるためです。
一点注意すべき事は、ここで求められる極小値は「局所的な」極小値（local minima）であり、必ずしも「大域的な」極小値（global minimum）であるとは限りません。
後者は、$`3N_\mathrm{atom}-6`$次元のPESの全域を調べないと発見できないため、新しいglobal minimumを見つけたと主張する際には注意が必要です。

構造最適化・エネルギー微分の概要としては、Szabo: Appendix Cが簡単かと思います。

## インプットファイル

詳しいことはマニュアルもご参照ください。
とりあえず、ミニマムに近い入力ファイルで、N<sub>2</sub>の構造最適化をしてみましょう。
[input_files/03_n2_opt.input](input_files/03_n2_opt.input)です。
計算レベルは(R)HF/6-31G(d)です。
```
&GATEWAY
  Coord = 2
  Angstrom
  N 0.0 0.0 0.0
  N 1.0 0.0 0.0
  Basis = 6-31G*
  Group = C1
  NoCD

>>> Do While

&SEWARD

&SCF

&SLAPAF

>>> End Do
```

`>`で始まる行は、EMILコマンドと呼ばれるものです。
シェルスクリプトや他の言語と同様に、`Do While`と`End Do`（これらは小文字でもOKです[^1]）。
上に書いたとおり、構造最適化計算はエネルギーの計算と勾配の計算を繰り返し行う必要があるため、EMILコマンドを使って「（ある条件が満たされるまで）繰り返し計算を行う」という設定をしています。
ちなみにこのときの条件は、「(`&SLAPAF`で指定される）しきい値を満たすまで」です。

「`&SLAPAF`」というのが、構造最適化を行う[^2]モジュールです。
**EMILコマンドは省略できません**。
SLAPAFの意味は現状分かりません。

ちなみに、`&SLAPAF`は分子の構造を動かすだけです。
構造最適化には勾配が必要なので、別に勾配を計算するモジュールが必要で、「`&ALASKA`」（アラスカ州のことだと思う）と呼ばれています。
インプットファイルに`&ALASKA`を書かなくて良い理由は、SLAPAFが使うべき勾配の情報を持っていない場合に、自動的にALASKAを呼ぶような設定がされているためです。
上のインプットファイルで計算をすると、標準エラー出力（？）に「`[ process      0]: xquit (rc =     65): _INVOKED_OTHER_MODULE_`」というものが表示されると思います。
これはエラーメッセージというわけではなく、インプットファイルに書かれていないモジュールを呼び出すとき（ここではSLAPAFがALASKAを呼ぶとき）に表示されるようになっています。
自分でALASKAを呼びたい場合は、`&SCF`と`&SLAPAF`のあいだに`&ALASKA`を書きましょう。
書いても結果は変わりませんが。

### 最適化が終了した構造

6行目は、最適化した構造の座標（coordinate）を表示しています。
計算の最初の構造（N-N間の距離が1.2 Angstrom）は`mol`に入っていますが、5行目で構造最適化をした際に、最適化した構造は`mol_eq`に入ります。
上の例だと、このような出力になると思います。
```
[[0.         0.         0.11593315]
 [0.         0.         2.1517382 ]]
```
なお、単位は原子単位（a.u. or Bohr）です。
ゼミや学会での発表では、多くの場合オングストローム単位で結果を示すため、単位を変換して結果を示すようにします。
「N<sub>2</sub>をHF/cc-pVDZで構造最適化すると、結合距離が1.077 Åになった」とでも表現できるでしょうか。
次の計算で使いたい場合には、単位が異なることに気をつけてください。
`unit="Bohr"`を用いると、原子単位で構造を指定することができます。
```python
mol = gto.M(atom='N 0 0 0.11593315; N 0 0 2.1517382', basis='ccpvdz', unit="Bohr")
```

### 構造最適化の詳細

エネルギーの一次微分は割と簡単に計算できるのですが、高校数学のように、一次微分がゼロになる点を直接計算できるわけではありません。
このため構造最適化は、Hartree--Fock法（あるいはSCF法）の計算と同じように、繰り返し計算により極小値を計算します（*cf*. ニュートン法）。
一次微分がゼロになる方向に原子を動かして、その後でエネルギーと一次微分を計算して、さらに原子を動かして･･･ということをしています。
構造最適化のそれぞれのサイクルの中で、エネルギーを計算するときにHatree--Fock(--Roothaan)方程式を繰り返し計算で行っています。
繰り返し計算というおおざっぱな言葉が出てきていて分かりづらいですが、やっていることは割と違います。

まずは構造最適化サイクルの1サイクル目を見てみます。
```
  2 Geometry optimization cycle 1
  3 Cartesian coordinates (Angstrom)
  4  Atom        New coordinates             dX        dY        dZ
  5    N   0.000000   0.000000   0.000000    0.000000  0.000000  0.000000
  6    N   0.000000   0.000000   1.200000    0.000000  0.000000  0.000000
  7 converged SCF energy = -108.914051975052
  8 --------------- SCF_Scanner gradients ---------------
  9          x                y                z
 10 0 N    -0.0000000000    -0.0000000000    -0.3121321959
 11 1 N     0.0000000000     0.0000000000     0.3121321959
 12 ----------------------------------------------
 13 cycle 1: E = -108.914051975  dE = -108.914  norm(grad) = 0.441422
```
`New coordinates`のすぐ下の行が、最初に入力した構造です。
7行目に`converged SCF energy = -108.914051975052`と表示されており、
ここでは`verbose=0`のため何も表示されていませんが、[前のページ](02_sp_output.md)でご説明したとおりのSCF計算が行われています。
そして10・11行目に、その分子構造での（解析的）勾配が表示されています。
a.u./bohrという単位を使っています。
なお、勾配はSCF計算が収束した後（エネルギーが得られた後）でないと得られないことに注意してください。
なので、SCF計算が収束しない場合は、その時点でプログラムが異常終了することが多いです。

で、上のサイクルが終わった後に、次の構造最適化サイクルに移ります。
```
 15 Geometry optimization cycle 2
 16 Cartesian coordinates (Angstrom)
 17  Atom        New coordinates             dX        dY        dZ
 18    N   0.000000   0.000000   0.079377    0.000000  0.000000  0.079377
 19    N   0.000000   0.000000   1.120623    0.000000  0.000000 -0.079377
 20 
 21 WARN: Large deviations found between the input molecule and the molecule from chkfile
 22 Initial guess density matrix may have large error.
 23 
 24 converged SCF energy = -108.95047828901
 25 --------------- SCF_Scanner gradients ---------------
 26          x                y                z
 27 0 N     0.0000000000    -0.0000000000     0.1553466138
 28 1 N    -0.0000000000     0.0000000000    -0.1553466138
 29 ----------------------------------------------
 30 cycle 2: E = -108.950478289  dE = -0.0364263  norm(grad) = 0.219693
```
18・19行目で表示される構造が、1サイクル目の構造とは違います。
21・22行目は気にしないで良いです。
24行目では、再びSCF計算をしています。
構造最適化サイクルで、毎回SCF計算と解析的勾配の計算をしているわけです。
エネルギー・勾配ともに減少していることに注意してください。
極小値ではエネルギーが局所的に最小値となっているはずなので、エネルギーが減少するという挙動は正しいです。
また、極値では勾配がゼロに近くなっているはずなので、勾配が減少するという挙動も正しいです。
ただ、必ずしも単調減少していくわけではありません。
少なくとも3*N*<sub>atom</sub>-6次元でのパラメータの最適化なので、エネルギーが増えたりすることもよくあります。

そして最後の構造最適化サイクルでは、
```
 85 --------------- SCF_Scanner gradients ---------------
 86          x                y                z
 87 0 N    -0.0000000000    -0.0000000000    -0.0000031240
 88 1 N     0.0000000000     0.0000000000     0.0000031240
 89 ----------------------------------------------
 90 cycle 6: E = -108.955558787  dE = -4.74512e-08  norm(grad) = 4.41806e-06
```
というように、勾配の値がかなり小さくなります（3.12D-6）。
`verbose=4`とすると、追加でConvergence criteria（収束しきい値）に関する情報も表示され、
```
6 Convergence criteria:
6 * Gradient RMS: 3.12e-06 < 0.00015 => OK
6 * Gradient maximum: 3.12e-06 < 0.00045 => OK
6 * Step RMS: 1.55e-06 < 0.0012 => OK
6 * Step maximum: 1.55e-06 < 0.0018 => OK
6 * All criteria matched
```
というように、勾配のRMS (root mean square)、勾配の最大値、ステップ（原子の変位）のRMS・最大値を計算し、
それらの値全てがしきい値（0.00015, 0.00045, 0.0012, 0.0018）より小さくなった場合に、「構造最適化計算が収束」したと判定します。
構造最適化した構造を議論する際は、最後に出てきた構造を用いて議論すれば良いと思います。

### 基準振動解析

[別ページ](08_property.md)に書きました。
極小値であるか極大値であるかは、二次微分を計算すると分かるのですが、
なんか直線分子の場合はバグっているような･･･。
PySCFディレクトリにあると思われる`examples/10-thermochemistry.py`をご参照のうえ、`freq_info`の結果を表示してみましょう。
極小値（付近）の場合は`freq_au`や`freq_wavenumber`がすべて実数になります。

## 演習問題

- ~~NH<sub>3</sub>を、6-31Gと6-31G(d)基底関数で構造最適化してみましょう。
どちらの構造が正しいでしょうか。
そして、なぜ正しくない構造が得られるでしょうか。
基底関数に含まれている関数の角運動量をもとに、考えてみましょう。~~ 保留
- 上記の構造最適化1サイクル目に表示されている
```
13 cycle 1: E = -108.914051975  dE = -108.914  norm(grad) = 0.441422
```
のうち、`norm(grad) = 0.441422`はどのような計算式により計算されているでしょうか。
- ベンゼン（でも何でも良いですが）の「[MP2](https://pyscf.org/user/mp.html)/cc-pVDZ//HF/6-31G(d)」計算をしてみましょう。
ここでは、HF/6-31G(d)の構造最適化を行い、最適化した構造を用いてMP2/cc-pVDZによる一点計算（エネルギー計算）をするという意味です。
ご参考のために、H<sub>2</sub>のMP2/cc-pVDZ//HF/6-31G(d)は、`E(MP2) = -1.15478598152265  E_corr = -0.0262803424848388`となりました。
- *cis*-1,3-butadieneと*trans*-1,3-butadieneを任意の計算レベル（手法や基底関数を自由に決めて良い）で構造最適化を行い、どちらが何kcal/mol安定か調べてみましょう。結果を示すときは、計算レベルも記載するようにしましょう。
- [ディールス・アルダー反応](https://ja.wikipedia.org/wiki/%E3%83%87%E3%82%A3%E3%83%BC%E3%83%AB%E3%82%B9%E3%83%BB%E3%82%A2%E3%83%AB%E3%83%80%E3%83%BC%E5%8F%8D%E5%BF%9C)の反応エネルギーを計算してみましょう。とりあえず、反応物（別々に）と生成物の構造最適化を行い、左辺と右辺とでエネルギーを比較します。左辺と右辺、どちらのエネルギーがどれだけ低くなるでしょうか。またこの結果から、例えば常温で常識的な時間で反応が起こる・起こらないについて議論することができるでしょうか。時間があれば、基底関数を変化させたときにどの程度計算時間やエネルギー差が変化するか見てみましょう。分子の初期構造は可視化ソフトウェアで作成することをオススメします。
- 時間があるなら、数値的に勾配を計算するプログラムを作成して、解析的な勾配と一致することを確認してください。

---

[^1]: EMILコマンドの「`>`」は、最初の1つで十分です。また、スペースもある程度省略できるようです。なので、`>dowhile`から`>enddo`のように書いても認識されるようです。
[^2]: 正確には、おそらく勾配に従って分子構造を一度だけ動かすモジュール。EMILコマンドを省略すると、挙動が分かると思います。
