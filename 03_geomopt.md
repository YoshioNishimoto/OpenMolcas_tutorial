# 構造最適化

構造最適化（geometry optimization）をします。
構造最適化は、ポテンシャルエネルギー面（PES; potential energy surface）の極値を見つけることです。
PESは、教科書とかでは三次元で書かれますが、実際には$`3N_\mathrm{atom}-6`$次元（自由度に一致。直線分子の場合は？）の超曲面になります。
イメージしづらいですが。
「極値」だと、極小値・極大値のどちらを計算しているのか分かりませんが、とりあえずここでは極小値を計算することを考えています。
極大値の計算は、可能であれば別の機会に･･･。
極大値は一般的に鞍点（あんてん; saddle point）と呼ばれており、$`3N_\mathrm{atom}-6`$つの基準振動の中で一つの振動モードのみが上に凸の場合に、
遷移構造・遷移状態（TS; transition structure, transition state）と呼ばれています。

教科書的に、分子のエネルギーの極小値を計算するというのは、例えばH<sub>2</sub>分子のPESの極小値を求めるというのはありうるかと思います。
二原子分子の場合は自由度が1であったため、自由度に対応する原子間距離を変化させながらエネルギーを計算し、横軸に原子間距離と縦軸にエネルギーをプロットすると、極小値を同定することができます。
ですがこれ以上大きな分子、三原子分子であったとしても自由度は3つとなり、例えば自由度の軸に沿ってそれぞれ10個の一点計算をするとしても、三つの軸に沿って原子を動かしていくと、最終的に1000回の一点計算が必要になります。
しかも、この計算を行ったとしても必ず極小値が見つかるわけではないですし、しかもそれぞれの軸に沿って10個の計算を行ったとしてもかなり荒い近似的な極小値（せいぜい精度は0.1 Angstrom程度と考えられる）しか見つかりません。
そこで、構造最適化をして自動かつ正確に極小値を求めます。

構造最適化するためには、勾配（gradient）を計算する必要があります。エネルギーを原子の核座標に関して一次微分したものです。
計算した勾配は、構造最適化中に原子を動かす方向を決めるのに必要で、さらに収束条件の判定（極値では勾配がゼロになっているはずなので、ある閾値よりも勾配が小さくなっていれば、構造最適化が収束したと判断する）にも用います。
計算の詳細は置いておいて･･･この勾配は多くの場合、解析的（analytic）に計算します。
これは高校で勉強したような、$`f(x) = x^n`$から$`f(x) = nx^{n-1}`$を計算するような方法です。
高校で勉強したと思われる導関数の定義を用いて、数値的（numerical）な計算をしているわけではありません。
つまり、勾配を計算する際に、少し原子を動かしてエネルギーを計算し、そのエネルギーの差分をとる･･･ということは**していません**。

関数の場合は勾配を計算してやれば、$`f^\prime(x) = 0`$となる$`x`$を計算することで極値も求められますが、
量子化学計算は自由度が大きいためそのようにして極値を求めることができません。
そのため、勾配を計算して、その勾配（や近似的、あるいは解析的二次微分）にしたがって原子を動かし、
新しい構造を用いて勾配を計算して、その勾配にしたがって原子を動かし･･･というように繰り返し計算を行います。
このため、エネルギーと勾配の計算を繰り返し行っていく必要が出てきます。
原子を動かすと分子軌道が変化するためエネルギーが変化し、エネルギーが変化すれば勾配も変化するためです。
インプットが省略されるので分かりづらいですが･･･。

量子化学計算では、多くの場合まず構造最適化計算をして、その構造でのエネルギーやプロパティを用いて議論を行います。
というのも、エネルギーが低い構造ほどその分子構造（配座？）をとる確率が高くなるためです。
何らかの相対エネルギーを計算するというときも、基本的にはまず構造最適化を行います。
一点注意すべき事は、ここで求められる極小値は「局所的な」極小値（local minima）であり、必ずしも「大域的な」極小値（global minimum）であるとは限りません。
後者は、$`3N_\mathrm{atom}-6`$次元のPESの全域を調べないと発見できないため、新しいglobal minimumを見つけたと主張する際には注意が必要です。

構造最適化・エネルギー微分の概要としては、Szabo: Appendix Cが簡単かと思います。

## インプットファイル

詳しいことはマニュアルもご参照ください。
とりあえず、ミニマムに近い入力ファイルで、N<sub>2</sub>の構造最適化をしてみましょう。
[input_files/03_n2_opt.input](input_files/03_n2_opt.input)です。
計算レベルは(R)HF/6-31G(d)です。
```
&GATEWAY
  Coord = 2
  Angstrom
  N 0.0 0.0 0.0
  N 1.0 0.0 0.0
  Basis = 6-31G*
  Group = C1
  NoCD

>>> Do While

&SEWARD

&SCF

&SLAPAF

>>> End Do
```

`>`で始まる行は、EMILコマンドと呼ばれるものです。
シェルスクリプトや他の言語と同様に、`Do While`と`End Do`（これらは小文字でもOKです[^1]）。
上に書いたとおり、構造最適化計算はエネルギーの計算と勾配の計算を繰り返し行う必要があるため、EMILコマンドを使って「（ある条件が満たされるまで）繰り返し計算を行う」という設定をしています。
ちなみにこのときの条件は、「(`&SLAPAF`で指定される）しきい値を満たすまで」です。

「`&SLAPAF`」というのが、構造最適化を行う[^2]モジュールです。
**EMILコマンドは省略できません**。
SLAPAFの意味は現状分かりません。

ちなみに、`&SLAPAF`は分子の構造を動かすだけです。
構造最適化には勾配が必要なので、別に勾配を計算するモジュールが必要で、「`&ALASKA`」（アラスカ州のことだと思う）と呼ばれています。
インプットファイルに`&ALASKA`を書かなくて良い理由は、SLAPAFが使うべき勾配の情報を持っていない場合に、自動的にALASKAを呼ぶような設定がされているためです。
上のインプットファイルで計算をすると、標準エラー出力（？）に「`[ process      0]: xquit (rc =     65): _INVOKED_OTHER_MODULE_`」というものが表示されると思います。
これはエラーメッセージというわけではなく、インプットファイルに書かれていないモジュールを呼び出すとき（ここではSLAPAFがALASKAを呼ぶとき）に表示されるようになっています。
自分でALASKAを呼びたい場合は、`&SCF`と`&SLAPAF`のあいだに`&ALASKA`を書きましょう。
書いても結果は変わりませんが。

## EMILコマンドの別の使い方

構造最適化以外にもEMILコマンドを使うことができます。
例えば二原子分子のポテンシャルエネルギー面を計算するときは、原子間距離を変化させながらエネルギーを計算していきます。
このとき、外部のスクリプトを使ってループを回しても良いですが、OpenMolcasだけでこれを実現することが可能です。
･･･10回程度の計算であれば手動でも構いませんが、このような処理を手動で行うのは極力避けましょう。
より詳細はマニュアルの4.1.3.2 EMIL commands参照。

例えば、N<sub>2</sub>の原子間距離を1.0 Angstrom, 1.1 Angstrom, ..., 2.0 Angstromと伸ばしながら(R)HF/6-31G(d)レベルで一点計算するインプットファイルは次のような感じになります。

```
> foreach DIST in (1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0)

&GATEWAY
  Coord = 2 
  Angstrom
  N 0.0 0.0 0.0 
  N $DIST 0.0 0.0 
  Basis = 6-31G*
  Group = C1
  NoCD

&SEWARD

&SCF

> enddo
```
ここの`DIST`という変数を、`(1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0)`で指定する数値に変化させながら繰り返し計算をしていくというものです。
しかし、数値のリストを手動で書いていくというのも手間です。
そこで、次のような感じにすることもできます。
```
> export DIST = 1.0
> foreach L in (1 .. 41)

&GATEWAY
  Coord = 2
  Angstrom
  N 0.0 0.0 0.0
  N $DIST 0.0 0.0
  Basis = 6-31G*
  Group = C1
  NoCD

&SEWARD

&SCF

> eval DIST = $DIST + 0.1
> enddo
```
この場合はN<sub>2</sub>の原子間距離を1.0から5.0まで変化させながらスキャンしてくれるようです。
その後、例えば`Total SCF energy`で`grep`するなどすると、エネルギーを取り出すことが可能です。
ループ中にエネルギーを取り出すなど、もう少し上手な方法は現状不明です。

シェルのコマンドを組み合わせることも可能（4.1.3.3 Use of shell parameters in input参照）ですが、そのあたりはご自身でお試しください。
先の例だと、シェルの方で`export DIST=1.0`みたいにしておくと、インプットファイルで`$DIST`を参照できるようです。
アウトプットを分けたりする場合にはこちらの方が便利でしょう。

## アウトプットファイル

### 最適化が終了した構造

構造最適化が上手くいけば、（私が行った計算の場合は）868行目から`&LAST_ENERGY`というモジュールが呼び出されます。
これは、構造最適化が終わった最後の構造のエネルギーを計算するというものです。[^3]
このときの原子間距離は
```
                    *******************************************
                    *    InterNuclear Distances / Angstrom    *
                    *******************************************

               1 N1            2 N2
    1 N1       0.000000
    2 N2       1.078374        0.000000
```
に示されていることから分かるとおり、1.078374 Angstromとなっていることが分かります。
つまり、(R)HF/6-31G(d)レベルでN<sub>2</sub>を構造最適化した結果、原子間距離は1.078 Angstromになったとの結論です。
ちなみに、Geminiに尋ねたところ、実験値は1.0978 Angstrom程度とのことです。[^4]
0.02 Angstrom程度のズレがありますが、そこまで悪くはないでしょう。
なお、一般的には原子間距離（結合長）をAngstrom単位で表します。
プログラム内部ではbohr (atomic unit)[^5]を用いたり、アウトプットでもBohrで表示されたりもしますが、結果の報告ではあまり使われません。

そして、もう一度Hartree–Fock計算が行われ、エネルギーは`-108.9439494708` hartreeであると分かります。
インプットファイルに書いた構造は原子間距離が1.0000 Angstromで、エネルギーは`-108.9174747353` hartreeでしたが、
構造最適化により1.0978 Angstomになり、エネルギーもずいぶん安定になったことが分かります。

二原子分子であれば自由度は1なので核間距離だけ分かれば十分ですが、
一般的には核間距離だけ分かっても使いづらいので、xyz形式のファイルを使って可視化することが多いです。
アウトプットファイルからは、
```
 *********************************************************
 * Nuclear coordinates of the final structure / Angstrom *
 *********************************************************
```
に構造が書き込まれていますので、一行目に原子数を追加し、二行目に適当なコメントを付け加えることで、可視化ソフトウェアで可視化することができます。
あるいは、同じディレクトリに（ファイル名が変わっていなければ）おそらく`03_n2_opt.Opt.xyz`というようなファイルができており、
ここに最終的な構造が書き込まれています（計算が終わっていなくても、最新の構造が書き込まれるはず）。
また、`03_n2_opt.geo.molden`には構造最適化の履歴がmolden形式で書き込まれていますので、
可視化ソフトウェアを用いることでどのように分子が最適化されていくかを見ることができます。
構造を取得する方法は、どれでも構いません。

あとは構造最適化で新しく呼ばれるモジュールの詳細を簡単に説明しておきます。

### &ALASKA

`&ALASKA`はエネルギーを核座標に対して微分したベクトルを計算するモジュールです。
この微分値は解析的に計算されます。
Hartree–Fockの場合はエネルギーが変分エネルギーに対応するためあまり難しくないです。
しかし、後の回で取り扱うSA-MCSCFの場合はエネルギーが変分エネルギーに対応しないため、追加で`&MCLR`というモジュールが呼ばれます。

とは言え、あまり説明することはないと思います。
私の場合は472行目に
```
Conventional ERI gradients!
```
というのが表示されますが、もしもCholesky decompositionを使った場合は477行目に
```
RI-ERI gradients!
```
などと表示されます。
どちらを使っているか確認しておきましょう。

計算された勾配ベクトルは
```
 **************************************************
 *                                                *
 *              Molecular gradients               *
 *                                                *
 **************************************************

  Irreducible representation: a  
 ------------------------------------------------------------------------------------------
                              X                       Y                       Z
 ------------------------------------------------------------------------------------------
  N1                3.90515107079043E-01    3.60721902715542E-16    3.77769006752029E-15
  N2               -3.90515107079050E-01   -3.60721902715540E-16   -3.77769006752028E-15
 ------------------------------------------------------------------------------------------
```
にて表示されます。
ちなみに、単位はhartree/bohrと呼ばれるものです。
a.bcdE-xyというのは$`a.bcd \times 10^{-xy}`$のことです。
y軸とz軸に沿った勾配がほとんどゼロ（機械誤差）になっているというのは、これらの軸の座標ゼロなので、特に力が働かないことから来ています。

数値微分を計算することも可能です。
エネルギー計算をしたあとで
```
&ALASKA
  NUMERICAL
  DELTA = 1.0D-03
```
というような感じで書くと、数値微分をしてくれます。
`NUMERICAL`は数値微分を行うためのキーワードで、`DELTA`というのが数値微分を行う際の小さな変位です。
`DELTA`の単位はatomic unitです。
分子のサイズにもよりますが、とりあえず`DELTA = 1.0D-03`あたりから始めると良いでしょう。

### &SLAPAF

`&SLAPAF`は`&ALASKA`が計算した勾配ベクトルを使って原子を動かしていくモジュールです。
構造最適化は$`3N-6`&次元での最適化問題ですから、本来はそれなりに複雑な問題を解きます。
特に、一次微分だけではなかなか収束しづらいため、近似的に二次微分を計算して収束を早めるなどの計算もしています。
そのあたりの詳細が
```
++       Slapaf input parameters:
         ------------------------

 Maximum number of iterations:              2000
 Convergence test a la Schlegel.
 Convergence criterion on gradient/para.<=: 3.0E-04
 Convergence criterion on step/parameter<=: 3.0E-04
 Convergence criterion on energy change <=: 0.0E+00
 Parameters for step-restricted optimization
 Maximum step length (initial seed):       3.00E-01

 -RFO activated with parameters:
   Maximum number of data points used in RFO:      5
 Line search is performed


 -Optimization for minimum.
  Optimization method: RS-RFO.

 -Initial Hessian guessed by Hessian Model Function (HMF).
  HMF augmented with weak interactions.

 -Hessian update method: Broyden-Fletcher-Goldfarb-Shanno
  Maximum number of points in Hessian update:  5

 -Relaxation will be done on non-redundant internal coordinates, based on
  force constant weighted redundant internal coordinates.
```
あたりに示されています。
なお、構造最適化を行うときは直交座標（cartesian coordinates)で原子を動かすのではなく、
内部座標（internal coordinates）という座標系で原子を動かします。
内部座標は原子間距離・角度・二面角により定義されています。
簡単に（と言うか何も考えなくても）並進と回転の寄与を除くことができ、
さらに直交座標系での最適化よりも早く収束させられることが知られています（そのあたりの数理までは把握していません）。
内部座標の定義に関しては
```
 ******************************************
 * Statistics of the internal coordinates *
 ******************************************
 Translations and Rotations:         0
 Bonds                     :         1
 Angles                    :         0
 Torsions                  :         0
 Out-of-plane angles       :         0
```
に示されています。
ここではN<sub>2</sub>間の結合長しか自由度がありませんので、特に面白いことはないでしょう。

構造最適化の状況は、`Energy Statistics for Geometry Optimization`から始まる、次のブロックを参照しましょう。
```
**********************************************************************************************************************
*                                    Energy Statistics for Geometry Optimization                                     *
**********************************************************************************************************************
                       Energy     Grad      Grad              Step                 Estimated   Geom       Hessian
Iter      Energy       Change     Norm      Max    Element    Max     Element     Final Energy Update Update   Index
  1   -108.91747474  0.00000000 0.552272  0.390515 nrc001   0.212132* nrc001     -108.95889512 RS-RFO  None      0
  2   -108.94011848 -0.02264374 0.162916 -0.115199 nrc001  -0.064835  nrc001     -108.94404015 RS-RFO  BFGS      0
  3   -108.94394881 -0.00383033 0.002304  0.001629 nrc001   0.000810  nrc001     -108.94394947 RS-RFO  BFGS      0
  4   -108.94394947 -0.00000066 0.000007 -0.000005 nrc001  -0.000002  nrc001     -108.94394947 RS-RFO  BFGS      0

       +----------------------------------+----------------------------------+
       +    Cartesian Displacements       +    Gradient in internals         +
       +  Value      Threshold Converged? +  Value      Threshold Converged? +
 +-----+----------------------------------+----------------------------------+
 + RMS + 1.2148E-06  1.2000E-03     Yes   + 6.9170E-06  3.0000E-04     Yes   +
 +-----+----------------------------------+----------------------------------+
 + Max + 1.2149E-06  1.8000E-03     Yes   + 4.8911E-06  4.5000E-04     Yes   +
 +-----+----------------------------------+----------------------------------+

 Geometry is converged in   4 iterations to a Minimum Structure
```
最初の方は構造最適化のステップが進むにつれ、エネルギーや勾配ベクトルがどのように変化していくかを示しています。
`Energy Change`等がどんどん減少していっており、収束していることがわかりやすくなっていることと思います。

下の方は、収束判定の結果を示しています。
直交座標系で原子がどれだけ動くかや、内部座標系での勾配をチェックして、しきい値（`Threshold`）よりも小さければ`Converged?`のところに`Yes`が表示され、
基本的にはすべて`Yes`になると収束したと見なされ、計算を終了します。
今回は4サイクルで局所的な（実際には大域的）安定構造を見つけました。

このしきい値は変更することもできます。
例えば`THRS = 1.0D-06, 1.0D-05`という感じにします。
一つ目の値がエネルギーのしきい値、二つ目が勾配ベクトルのRMS (root-mean-square)のしきい値に対応します。
あまり変更する必要はないでしょう。

最近OpenMolcasにRVO (restricted variance optimization)なる方法が追加されました。
あまり詳しくないので説明しませんが（詳細は[原論文](https://doi.org/10.1021/acs.jctc.0c00257)参照）、機械学習的な方法で少し構造最適化が早くなるという方法です。
```
&SLAPAF
  KRIGING
```
で使うことができます。
もっとも、この系は簡単なので、`KRIGING`を使ったところで早くなりませんが。

### アウトプットについて

最近（2021年か2022年頃以降）のOpenMolcasで構造最適化を行うと、2サイクル目以降はアウトプットが省略されます。
これを防ぐには、インプットファイルのはじめの方に`> EXPORT MOLCAS_PRINT = 3`とでも書いておきましょう。
何も書かない場合よりもアウトプットが少し増えてしまいますが、各構造最適化サイクルでもエネルギー計算の詳細が表示されるようになります。

### 構造最適化が終了しない場合

大抵初期構造が悪いです。
化学的にもっともらしい構造を作って構造最適化を始めましょう。
OpenMolcasの場合は`Step Max`の値がやたら落ちづらいです。
`Step Max`はプログラムが原子をどのように動かすかに関係しており、
必ずしも安定構造に近いかどうかを反映しません（理想的には当然反映しますが）。
どうしてもダメな場合は、諦めても良いでしょう。

### Constrained optimizationや基準振動解析と遷移状態

余裕があれば別の回で。
前者の例は、とりあえず[03_scan_cp.input](input_files/03_scan_cp.input)で、シクロプロパンのC–C距離を伸ばしながらrelaxed scanをしています。
この書き方が唯一ではないです。

---

## 演習問題

- 計算される勾配ベクトルに並進に対応するベクトルは含まれているでしょうか。どのようにすると確認できるでしょうか。
- 解析的微分と数値微分がほとんど一致するかを確認しましょう。
- `Grad Norm`はどのように計算されているかを教えてください。
- `&ALASKA`に`SHOW`というオプションを加えると、寄与ごとの勾配ベクトルが表示されるようになると思います（[03_cyclopropane_grad.out](03_cyclopropane_grad.out)参照）。`The Nuclear Repulsion Contribution`がどのように計算できるか（プログラム含めて）教えてください。
- *cis*-1,3-butadieneと*trans*-1,3-butadieneを任意の計算レベル（手法や基底関数を自由に決めて良い）で構造最適化を行い、どちらが何kcal/mol安定か調べてみましょう。結果を示すときは、計算レベルも記載するようにしましょう。
- [ディールス・アルダー反応](https://ja.wikipedia.org/wiki/%E3%83%87%E3%82%A3%E3%83%BC%E3%83%AB%E3%82%B9%E3%83%BB%E3%82%A2%E3%83%AB%E3%83%80%E3%83%BC%E5%8F%8D%E5%BF%9C)の反応エネルギーを計算してみましょう。とりあえず、反応物（別々に）と生成物の構造最適化を行い、左辺と右辺とでエネルギーを比較します。左辺と右辺、どちらのエネルギーがどれだけ低くなるでしょうか。またこの結果から、例えば常温で常識的な時間で反応が起こる・起こらないについて議論することができるでしょうか。時間があれば、基底関数を変化させたときにどの程度計算時間やエネルギー差が変化するか見てみましょう。分子の初期構造は可視化ソフトウェアで作成することをオススメします。
- 時間があるなら、数値的に勾配を計算するプログラムを作成して、解析的な勾配と一致することを確認してください。

---

[^1]: EMILコマンドの「`>`」は、最初の1つで十分です。また、スペースもある程度省略できるようです。なので、`>dowhile`から`>enddo`のように書いても認識されるようです。
[^2]: 正確には、おそらく勾配に従って分子構造を一度だけ動かすモジュール。EMILコマンドを省略すると、挙動が分かると思います。
[^3]: これに関してOpenMolcasの場合、正確には収束の判定がされてからもう一度構造を動かしてからエネルギーを計算するようになっていま。個人的には収束を判定したときの構造のエネルギーを用いるべきだと思っています。GaussianやGAMESS-USはそうなっているはず。きちんと収束していれば、どちらのエネルギーを使ってもほとんど変わらないはずですけれど。
[^4]: 私がGeminiで得た答えは嘘っぱちな文献を参照していたので怪しいですが、[違うサイト](https://www.eng.kagawa-u.ac.jp/~tishii/Lab/hybrid/N2/N2.html)で似たような値を提示しているので、とりあえずこの値で良いでしょう。
[^5]: bohrは人名なので通常大文字で始まりますが、単位として用い、かつ省略しない場合は小文字で始めるというウワサがあります。hartreeも同様。
